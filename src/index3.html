<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <style>
        body{
            margin: 0;
        }
        canvas{
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
<div id="stats-output"></div>
<script src="https://cdn.bootcss.com/three.js/91/three.js"></script>
<script src="./lib/Stats.js"></script>
<script src="./lib/dat.gui.js"></script>
<script src="./lib/SceneUtils.js"></script>
<script src="./lib/OrbitControls.js"></script>
<script src="./lib/Reflector.js"></script>
<script src="./index.js"></script>
<script>
    // 帧率辅助
    var stats = new Stats();
    stats.setMode(0);
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.left = '0px';
    stats.domElement.style.top = '0px';
    document.getElementById('stats-output').appendChild(stats.domElement);

    // 三要素
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    var renderer = new THREE.WebGLRenderer();

    scene.fog = new THREE.Fog(0x000000, 0.015, 500);
    camera.position.set(20,0,30);
    camera.lookAt(new THREE.Vector3(0,0,0));
    renderer.setSize(window.innerWidth, window.innerHeight, true);
    renderer.setClearColor(0x222222);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // 鼠标控制辅助
    var cameraControls = new THREE.OrbitControls(camera, renderer.domElement);
    cameraControls.target.set( 0, 40, 0);
    cameraControls.maxDistance = 400;
    cameraControls.minDistance = 10;
    cameraControls.update();

    // 轴辅助
    var axes = new THREE.AxesHelper(20);
    //scene.add(axes);

    // 窗体大小改变时重置分辨率等参数
    function onResize(){
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // 浏览器改变事件
    window.addEventListener('resize', onResize, false);

    // 环境光
    var ambientLight = new THREE.AmbientLight(0x666666, 0.8);
    scene.add(ambientLight);

    // 添加聚光灯光源
    var spotLight = new THREE.SpotLight(0xffffff);
    spotLight.position.set(50,50,0);
    spotLight.castShadow = true;
    scene.add(spotLight);

    /** =================================
     * 以上不变
     * ================================== **/

    /** 创建了两个六面体相机 **/
    var cubeCamera1 = new THREE.CubeCamera(1, 1000, 256);
    scene.add(cubeCamera1);
    var cubeCamera2 = new THREE.CubeCamera(1, 1000, 256);
    scene.add(cubeCamera2);

    // 通过相机的画面作为贴图
    var cubeMeterial = new THREE.MeshBasicMaterial({
        envMap: cubeCamera2.renderTarget.texture,
    });

    /** 用贝塞尔曲线生成水滴曲面 **/
    var points = [];
    const lang = 50;
    for ( var i = 0; i < lang; i ++ ) {
        const y = start(i);
        points.push( new THREE.Vector2(y, i  ) );
    }

    /** THREE提供的根据曲线生成物体网格 **/
    const water_m = new THREE.LatheBufferGeometry(points, 20);

    const water_mesh = new THREE.Mesh(water_m, cubeMeterial);
    water_mesh.rotation.set(0,0,Math.PI/2);
    scene.add(water_mesh);

    /** 慢速星空 **/
    /** star纹理 **/
    function makeStarTexture(){
        var canvas = document.createElement('canvas');
        canvas.width = 16;
        canvas.height = 16;
        var pen = canvas.getContext('2d');
        var gradient = pen.createRadialGradient(
            canvas.width/2,canvas.height/2,0,canvas.width/2,canvas.height/2,canvas.width/2
        );//创建放射状渐变
        gradient.addColorStop(0,'rgba(255,255,255,1)');
        gradient.addColorStop(0.2,'rgba(0,255,255,1)');
        gradient.addColorStop(0.4,'rgba(0,0,164,1)');
        gradient.addColorStop(1,'rgba(0,0,0,1)');
        pen.fillStyle = gradient;						//将笔触填充色设置为这个渐变放射状
        pen.fillRect(0,0,canvas.width,canvas.height);	//画矩形
        var texture = new THREE.Texture(canvas);		//生成贴图对象（参数是图片或canvas画布）
        texture.needsUpdate = true;						//将这个对象缓存到GPU
        return texture;
    }
    /** 创建星空基本粒子系统 **/
    var cloud;
    function initStarSky(){
        //粒子材质
        var material = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 3,
            transparent: true,
            blending: THREE.AdditiveBlending,
            map: makeStarTexture()
        });

        var geom = new THREE.Geometry();
        var range = 500;
        for (var i = 0; i < 10000; i++) {
            var particle = new THREE.Vector3(Math.random() * range - range / 2, Math.random() * range - range / 2, Math.random() * range - range / 2);
            geom.vertices.push(particle);
            var color = new THREE.Color(0x00ffcc);
            // color.setHSL(color.getHSL().h, color.getHSL().s, Math.random() * color.getHSL().l);
            geom.colors.push(color);
        }

        //创建粒子系统，相当于abc中的c
        cloud = new THREE.Points(geom, material);//参数是形状和材质
        cloud.sortParticles = true;					//粒子重新排序
        cloud.position.z = -100;
        scene.add(cloud);
    }

    initStarSky();
    /** =================================
     * 以下不变
     * ================================== **/
    animate();

    // 渲染方法
    var count=0;
    function animate() {
        requestAnimationFrame(animate);
        stats.update();
        cloud.position.x -= 0.5;
        if(cloud.position.x <= -100) {
            cloud.position.x = 200;
        }

        if ( count % 2 === 0 ) {

            cubeMeterial.envMap = cubeCamera1.renderTarget.texture;
            cubeCamera2.update( renderer, scene );

        } else {

            cubeMeterial.envMap = cubeCamera2.renderTarget.texture;
            cubeCamera1.update( renderer, scene );

        }

        count ++;

        renderer.render(scene, camera);
    }
</script>
</body>
</html>