<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <style>
        body{
            margin: 0;
        }
        canvas{
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
<div id="stats-output"></div>
<script src="https://cdn.bootcss.com/three.js/92/three.js"></script>
<script src="./lib/Stats.js"></script>  <!-- 帧率辅助 -->

<script src="./lib/OrbitControls.js"></script>  <!-- 镜头控制 -->
<script src="./lib/Reflector.js"></script> <!-- 反光网格 -->

<!-- 后处理相关 -->
<script src="./lib/EffectComposer.js"></script>
<script src="./lib/CopyShader.js"></script>
<script src="./lib/FXAAShader.js"></script>
<script src="./lib/RenderPass.js"></script>
<script src="./lib/ShaderPass.js"></script>
<script src="./lib/OutlinePass.js"></script>
<!-- /后处理相关 -->

<script src="./lib/THREE.MeshLine.js"></script>
<script src="./index.js"></script>
<script>
    /**
     * 进入高维 - https://threejs.org/examples/#webgl_clipping
     * 表面颜色动态改变 - https://threejs.org/examples/#webgl_multiple_renderers
     * 画面抖动效果 - https://threejs.org/examples/#webgl_postprocessing_glitch
     * 高光 - https://threejs.org/examples/#webgl_postprocessing_unreal_bloom
     * 这个或许可以用来做护盾的效果 - https://threejs.org/examples/#webgl_buffergeometry_drawcalls
     * 这个把点弄小点换下颜色估计可以做护盾 - https://threejs.org/examples/#webgl_custom_attributes_points2
     * 动态染色，闪光效果？ - https://threejs.org/examples/#webgl_simple_gi
     * 标签 - https://threejs.org/examples/#css2d_label 用DIV来做的
     * SVG做的LINES 可以用来做三维小地图 https://threejs.org/examples/#svg_lines
     * 边缘发光可以用外边框模拟 - https://threejs.org/examples/?q=line#webgl_postprocessing_outline
     * 另一个描边例子 - https://threejs.org/examples/#webgl_postprocessing_sobel
     * 简单的彗星尾巴（线条模拟） - https://www.clicktorelease.com/code/THREE.MeshLine/demo/birds.html
     * **/
    // 帧率辅助
    var stats = new Stats();
    stats.setMode(0);
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.left = '0px';
    stats.domElement.style.top = '0px';
    document.getElementById('stats-output').appendChild(stats.domElement);

    // 三要素
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    var renderer = new THREE.WebGLRenderer();

    scene.fog = new THREE.Fog(0x000000, 0.015, 500);
    // camera.position.set(20,0,30);
    camera.lookAt(new THREE.Vector3(0,0,0));
    renderer.setSize(window.innerWidth, window.innerHeight, true);
    renderer.setClearColor(0x222222);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // 鼠标控制辅助
    var cameraControls = new THREE.OrbitControls(camera, renderer.domElement);
    cameraControls.target.set( 0, 0, 0);
    cameraControls.maxDistance = 200;
    cameraControls.minDistance = 20;
    cameraControls.update();

    // 轴辅助
    var axes = new THREE.AxesHelper(20);
    scene.add(axes);

    // 窗体大小改变时重置分辨率等参数
    function onResize(){
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
        effectFXAA.uniforms[ 'resolution' ].value.set( 1 / window.innerWidth, 1 / window.innerHeight );
    }

    // 浏览器改变事件
    window.addEventListener('resize', onResize, false);

    // 环境光
    var ambientLight = new THREE.AmbientLight(0x666666, 0.8);
    scene.add(ambientLight);

    // 添加聚光灯光源
    var spotLight = new THREE.SpotLight(0xffffff);
    spotLight.position.set(50,50,0);
    spotLight.castShadow = true;
   // scene.add(spotLight);

    /** =================================
     * 以上不变
     * ================================== **/

    /** 创建了两个六面体相机 **/
    var cubeCamera1 = new THREE.CubeCamera(1, 1000, 256);
    scene.add(cubeCamera1);
    var cubeCamera2 = new THREE.CubeCamera(1, 1000, 256);
    scene.add(cubeCamera2);

    // 通过相机的画面作为贴图
    var cubeMeterial = new THREE.MeshBasicMaterial({
        envMap: cubeCamera2.renderTarget.texture,
    });

    /** 用贝塞尔曲线生成水滴曲面 **/
    var points = [];
    const lang = 50;
    for ( let i = 0; i < lang; i +=0.2) {
        const y = start(i);
        points.push( new THREE.Vector2(y, i  ) );
    }
    console.log('有多少个啊：', points);
    /**
     * points包含了(y,x)坐标，通过这个定位光锥的坐标
     * **/
    const cone_texture = new THREE.TextureLoader().load("./lib/imgs/lightray_red.jpg");
    const cone_group = new THREE.Group();

    for(let i=25; i< points.length; i+=25) {
        const p = createCone(points[i]);
        cone_group.add(p.plane1);
        cone_group.add(p.plane2);
    }
    /** 光锥创建方法 **/

    function createCone(position) {
        var material = new THREE.MeshBasicMaterial({ // 基本材质
            map: cone_texture,
            transparent: true,
            depthTest: true,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending
        });
        var height = 1.5;
        var width = 0.5;
        var geometry = new THREE.PlaneGeometry(width, height);
        var matrix1 = new THREE.Matrix4();
        var plane1 = new THREE.Mesh(geometry, material);
        // matrix1.makeRotationY(Math.PI/180 * 90);
       // matrix1.setPosition(new THREE.Vector3(0,0, height/-2));
      // geometry.applyMatrix(matrix1);


        plane1.rotation.z = Math.PI / 180 * 90;
        plane1.position.y = height * 100;
        let plane2 = plane1.clone();
        plane2.rotation.x = Math.PI / 180 * 90;

        plane1.position.copy(new THREE.Vector3(position.x + height / 2, position.y, 0));
        plane2.position.copy(new THREE.Vector3(position.x + height / 2, position.y, 0));

        return {plane1: plane1, plane2: plane2};
    }

    /** THREE提供的根据曲线生成物体网格 **/
    const water_m = new THREE.LatheBufferGeometry(points, 20);

    const water_mesh = new THREE.Mesh(water_m, cubeMeterial);
    water_mesh.rotation.set(0,0,Math.PI/2);
    scene.add(water_mesh);

    //cone_group.rotation.set(0,-Math.PI/180 * 90,0);
    var cone_group1 = cone_group.clone();
    var cone_group2 = cone_group.clone();
    cone_group1.rotation.y = Math.PI / 180 * 120;
    cone_group2.rotation.y = Math.PI / 180 * -120;
    water_mesh.add(cone_group);
    water_mesh.add(cone_group1);
    water_mesh.add(cone_group2);


    /** 慢速星空 **/
    /** star纹理 **/
    function makeStarTexture(){
        var canvas = document.createElement('canvas');
        canvas.width = 16;
        canvas.height = 16;
        var pen = canvas.getContext('2d');
        var gradient = pen.createRadialGradient(
            canvas.width/2,canvas.height/2,0,canvas.width/2,canvas.height/2,canvas.width/2
        );//创建放射状渐变
        gradient.addColorStop(0,'rgba(255,255,255,1)');
        gradient.addColorStop(0.2,'rgba(0,255,255,1)');
        gradient.addColorStop(0.4,'rgba(0,0,164,1)');
        gradient.addColorStop(1,'rgba(0,0,0,1)');
        pen.fillStyle = gradient;						//将笔触填充色设置为这个渐变放射状
        pen.fillRect(0,0,canvas.width,canvas.height);	//画矩形
        var texture = new THREE.Texture(canvas);		//生成贴图对象（参数是图片或canvas画布）
        texture.needsUpdate = true;						//将这个对象缓存到GPU
        return texture;
    }
    /** 创建星空基本粒子系统 **/
    var cloud, cloud2, lineMesh, lineMesh2;
    function initStarSky(){
        //粒子材质
        var material = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 3,
            transparent: true,
            blending: THREE.AdditiveBlending,
            map: makeStarTexture()
        });

        var geom = new THREE.Geometry();
        var range = 500;
        var rangex = 2000;
        for (var i = 0; i < 10000; i++) {
            var particle = new THREE.Vector3(Math.random() * rangex - rangex / 2, Math.random() * range - range / 2, Math.random() * range - range / 2);
            geom.vertices.push(particle);
            var color = new THREE.Color(0x00ffcc);
            // color.setHSL(color.getHSL().h, color.getHSL().s, Math.random() * color.getHSL().l);
            geom.colors.push(color);
        }

        // 创建粒子系统，相当于abc中的c
        cloud = new THREE.Points(geom, material);//参数是形状和材质
        cloud2 = new THREE.Points(geom, material); // 创建第2个

        cloud.sortParticles = true;					//粒子重新排序
        cloud2.sortParticles = true;
        cloud2.position.x = 2000;
       scene.add(cloud);
       scene.add(cloud2);

        /**
         * 线性立方体
         * **/
        var geometry = new THREE.BufferGeometry();
        var points = [];
        /** 定义顶点 **/
        for(let i=0; i<1000; i++) {
            const x = Math.random() * 2000 - 1000;
            const y = Math.random() * 500 - 250;
            const z = Math.random() * 500 -250;
            const lang = Math.random() * 100 + 200;
            points.push(x,y,z,x+lang, y ,z);
        }

        geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( points, 3 ) ); // 设置顶点们

        var material = new THREE.LineBasicMaterial({
            color: 0x638DAF,
            linewidth: 1,
            linecap: 'square',
            linejoin: 'bevel',
        });
        lineMesh = new THREE.LineSegments(geometry, material);
        lineMesh2 = lineMesh.clone();
        lineMesh2.position.x = 1800;
        //scene.add(lineMesh);
        //scene.add(lineMesh2);
    }

    initStarSky();

    /* 生成天空盒 */
    var skybox;
    function initSkyBox(){
        var urls = ["lib/skybox/posx.png","lib/skybox/negx.png",
            "lib/skybox/posy.png","lib/skybox/negy.png",
            "lib/skybox/posz.png","lib/skybox/negz.png"];
        var loader = new THREE.CubeTextureLoader();

        var textureCube = loader.load(urls);	//这是采用同步的方式，也可以异步

        var shader = THREE.ShaderLib["cube"];
        shader.uniforms["tCube"].value = textureCube;
        var material = new THREE.ShaderMaterial({
            fragmentShader:shader.fragmentShader,
            vertexShader:shader.vertexShader,
            uniforms:shader.uniforms,
            depthWrite:false,
            side:THREE.BackSide
        });
        skybox = new THREE.Mesh(new THREE.BoxGeometry(2000,2000,2000),material);
        scene.add(skybox);
    }
    initSkyBox();

    // 飞船附加物

    /** 线圈 **/
    var ship_g = new THREE.Geometry();
    for( let j = 0; j < Math.PI * 2.1; j += 2 * Math.PI / 180 ) {
        let v = new THREE.Vector3( Math.cos( j ), Math.sin( j ), 0 );
        ship_g.vertices.push( v );
    }
    var line = new MeshLine();
    line.setGeometry(ship_g);
    // 实现线圈
    var ship_line = new MeshLineMaterial({
        color: new THREE.Color(0x70c1b3),
        lineWidth: .05,
        side: THREE.DoubleSide
    });

    // 虚线线圈
    var ship_dash = new MeshLineMaterial({
        color: new THREE.Color(0x70c1b3),
        lineWidth: .05,
        dashArray: 0.333,
        dashRatio: 0.666,
        transparent: true,
        side: THREE.DoubleSide
    });

    // 红色虚线材质
    var ship_red_dash = new MeshLineMaterial({
        color: new THREE.Color(0xFF4308),
        dashArray: 0.5,
        dashRatio: 0.5,
        transparent: true,
        lineWidth: .05,
    });

    // 红色实线材质
    var ship_red_line = new MeshLineMaterial({
        color: new THREE.Color(0xFF4308),
        lineWidth: .1,
    });
    
    var line1_mesh = new THREE.Mesh(line.geometry, ship_line);
    line1_mesh.scale.set(3,3,3);
    line1_mesh.rotation.y = Math.PI/180 * 90;
    line1_mesh.position.x = 5;
    scene.add(line1_mesh);

    var line2_mesh = line1_mesh.clone();
    line2_mesh.scale.set(8,8,8);
    line2_mesh.position.x = 2;
    scene.add(line2_mesh);

    var line3_mesh = line1_mesh.clone();
    line3_mesh.scale.set(1.5,1.5,1.5);
    line3_mesh.position.x = -48;
    scene.add(line3_mesh);

    var q4_mesh = new THREE.Mesh(line.geometry, ship_red_dash);
    q4_mesh.scale.set(1.5,1.5,1.5);
    q4_mesh.rotation.y = Math.PI/180 * 90;
    q4_mesh.position.x = 1;
    scene.add(q4_mesh);

    var q5_mesh = q4_mesh.clone();
    q5_mesh.scale.set(1.3,1.3,1.3);
    q5_mesh.position.x = -48.5;
    scene.add(q5_mesh);

    var dash1_mesh = new THREE.Mesh(line.geometry, ship_dash);
    dash1_mesh.scale.set(3.3,3.3,3.3);
    dash1_mesh.rotation.y = Math.PI/180 * 90;
    dash1_mesh.position.x = 5;
    scene.add(dash1_mesh);

    /** 3个红色三角 **/
    var ship_line4_g = new THREE.Geometry();
    ship_line4_g.vertices.push(new THREE.Vector3(0, 7, 0));
    ship_line4_g.vertices.push(new THREE.Vector3(0, 5, 0));

    var line4 = new MeshLine();
    line4.setGeometry(ship_line4_g, function(p){return 1-p;});

    var line4_mesh = new THREE.Mesh(line4.geometry, ship_red_line);
    line4_mesh.position.set(2, 0, 0);

    var line5_mesh = line4_mesh.clone();
    var line6_mesh = line4_mesh.clone();

    line5_mesh.rotation.x = Math.PI/180 * 120;
    line6_mesh.rotation.x = Math.PI/180 * 240;

    var line_group = new THREE.Group();
    line_group.add(line4_mesh);
    line_group.add(line5_mesh);
    line_group.add(line6_mesh);
    scene.add(line_group);

    /** 尾巴上的3个三角形 **/


    /** 后期处理 **/
    var composer = new THREE.EffectComposer( renderer );

    var renderPass = new THREE.RenderPass( scene, camera );
    composer.addPass( renderPass );

    var outlinePass = new THREE.OutlinePass( new THREE.Vector2( window.innerWidth, window.innerHeight ), scene, camera );
    composer.addPass( outlinePass );

    var effectFXAA = new THREE.ShaderPass( THREE.FXAAShader );

    effectFXAA.uniforms[ 'resolution' ].value.set( 1 / window.innerWidth, 1 / window.innerHeight );
    effectFXAA.renderToScreen = true;
    composer.addPass( effectFXAA );

    outlinePass.selectedObjects = [];
    /** =================================
     * 以下不变
     * ================================== **/
    animate();

    // 渲染方法
    var count=0;
    function animate() {
        requestAnimationFrame(animate);
        stats.update();
        line_group.rotation.x += 0.01;
        dash1_mesh.rotation.x -= 0.01;
        cloud.position.x -= 1;
        cloud2.position.x -= 1;
        lineMesh.position.x -= 60;
        lineMesh2.position.x -= 60;
        q4_mesh.rotation.x -= 0.04;
        q5_mesh.rotation.x -= 0.04;
        if(cloud.position.x <= -1500) {
            cloud.position.x = 2500;
        }
        if(cloud2.position.x <= -1500) {
            cloud2.position.x = 2500;
        }
        if(lineMesh.position.x <= -1500) {
            lineMesh.position.x = 2300;
        }
        if(lineMesh2.position.x <= -1500) {
            lineMesh2.position.x = 2300;
        }

        if ( count % 2 === 0 ) {

            cubeMeterial.envMap = cubeCamera1.renderTarget.texture;
            cubeCamera2.update( renderer, scene );

        } else {

            cubeMeterial.envMap = cubeCamera2.renderTarget.texture;
            cubeCamera1.update( renderer, scene );

        }

        count ++;
       composer.render();
        //renderer.render(scene, camera);

    }
</script>
</body>
</html>