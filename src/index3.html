<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <title>three.js css2d - label</title>
    <style>
        body{
            background-color: #000;
            margin: 0;
        }
        canvas{
            display: block;
            width: 100%;
            height: 100%;
        }
        .title2d{
            position: relative;
            width: 150px;
            height: 40px;
            text-align: center;
            opacity: 0;
            transform: scale(0,0);
            transition: all 300ms;
        }
        .title2d.show{
            opacity: 1;
            transform: scale(1,1);
        }
        .title2d.show .t{
            opacity: 1;
            transform: translateY(0);
        }
        .title2d .t{
            position: absolute;
            top:0;
            left:0;
            width: 100%;
            height: 100%;
            line-height: 40px;
            font-size: 16px;
            color: #ffffff;
            z-index: 2;
            opacity: 0;
            transform: translateY(10px);
            transition: all 300ms;
        }
        .title2d .b{
            position: absolute;
            top:0;
            left:0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,.3);
        }
        .title2d .l1{
            width: 10px;
            height: 10px;
            position: absolute;
            top:0;
            left:0;
            border-top: solid 1px #00ff00;
            border-left: solid 1px #00ff00;
        }
        .title2d .l2{
            width: 10px;
            height: 10px;
            position: absolute;
            bottom:0;
            right:0;
            border-bottom: solid 1px #00ff00;
            border-right: solid 1px #00ff00;
        }
        .label2{
            width: 300px;
            color: #ffffff;
            font-size: 12px;
            opacity: 0;
            transition: all 300ms;
        }
        .label2.show{
            opacity: 1;
        }
        .label2.show p{
            transform: scale(1,1);
        }
        .label2 p{
            transition: 300ms;
            transform: scale(0,0);
        }
        .label2 i{
            color: #00ff00;
        }
    </style>
</head>
<body>
<div id="stats-output"></div>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="https://cdn.bootcss.com/three.js/92/three.js"></script>
<script src="./lib/Stats.js"></script>  <!-- 帧率辅助 -->

<script src="./lib/OrbitControls.js"></script>  <!-- 镜头控制 -->
<script src="./lib/Reflector.js"></script> <!-- 反光网格 -->
<script src="./lib/CSS2DRenderer.js"></script> <!-- 2D DIV -->

<!-- 后处理相关 -->
<script src="./lib/EffectComposer.js"></script>
<script src="./lib/CopyShader.js"></script>
<script src="./lib/FXAAShader.js"></script>
<script src="./lib/RenderPass.js"></script>
<script src="./lib/ShaderPass.js"></script>
<script src="./lib/OutlinePass.js"></script>
<!-- /后处理相关 -->

<script src="./lib/THREE.MeshLine.js"></script>
<script src="./index.js"></script>
<script>
    /**
     * 进入高维 - https://threejs.org/examples/#webgl_clipping
     * 表面颜色动态改变 - https://threejs.org/examples/#webgl_multiple_renderers
     * 画面抖动效果 - https://threejs.org/examples/#webgl_postprocessing_glitch
     * 高光 - https://threejs.org/examples/#webgl_postprocessing_unreal_bloom
     * 这个或许可以用来做护盾的效果 - https://threejs.org/examples/#webgl_buffergeometry_drawcalls
     * 这个把点弄小点换下颜色估计可以做护盾 - https://threejs.org/examples/#webgl_custom_attributes_points2
     * 动态染色，闪光效果？ - https://threejs.org/examples/#webgl_simple_gi
     * 标签 - https://threejs.org/examples/#css2d_label 用DIV来做的
     * SVG做的LINES 可以用来做三维小地图 https://threejs.org/examples/#svg_lines
     * 边缘发光可以用外边框模拟 - https://threejs.org/examples/?q=line#webgl_postprocessing_outline
     * 另一个描边例子 - https://threejs.org/examples/#webgl_postprocessing_sobel
     * 简单的彗星尾巴（线条模拟） - https://www.clicktorelease.com/code/THREE.MeshLine/demo/birds.html
     * 射线例子 - https://threejs.org/examples/?q=ray#webgl_octree_raycasting
     * **/
    // 帧率辅助
    var stats = new Stats();
    stats.setMode(0);
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.left = '0px';
    stats.domElement.style.top = '0px';
    document.getElementById('stats-output').appendChild(stats.domElement);

    // 三要素
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1500);
    var renderer = new THREE.WebGLRenderer();

   // scene.fog = new THREE.Fog(0x000000, 0.015, 1800);
    // camera.position.set(20,0,30);
    camera.lookAt(new THREE.Vector3(0,0,0));
    renderer.setSize(window.innerWidth, window.innerHeight, true);
    renderer.setClearColor(0x222222);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // 鼠标控制辅助
    var cameraControls = new THREE.OrbitControls(camera);
    cameraControls.target.set( 0, 0, 0);
    cameraControls.maxDistance = 200;
    cameraControls.minDistance = 20;
    cameraControls.update();

    // 轴辅助
    var axes = new THREE.AxesHelper(20);
   // scene.add(axes);

    // 窗体大小改变时重置分辨率等参数
    function onResize(){
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        effectFXAA.uniforms[ 'resolution' ].value.set( 1 / window.innerWidth, 1 / window.innerHeight );
    }

    // 浏览器改变事件
    window.addEventListener('resize', onResize, false);

    // 环境光
    var ambientLight = new THREE.AmbientLight(0x666666, 0.8);
    scene.add(ambientLight);

    /** =================================
     * 以上不变
     * ================================== **/

    /** 创建了两个六面体相机 **/
    var cubeCamera1 = new THREE.CubeCamera(1, 2000, 256);
    cubeCamera1.renderTarget.texture.minFilter = THREE.LinearMipMapLinearFilter;
    cubeCamera1.position.x = 8;
    scene.add(cubeCamera1);
    var cubeCamera2 = new THREE.CubeCamera(1, 2000, 256);
    cubeCamera2.renderTarget.texture.minFilter = THREE.LinearMipMapLinearFilter;
    cubeCamera2.position.x = 8;
    scene.add(cubeCamera2);

    // 通过相机的画面作为贴图
    var cubeMeterial = new THREE.MeshBasicMaterial({
        envMap: cubeCamera2.renderTarget.texture,
    });

    /** 用贝塞尔曲线生成水滴曲面 **/
    var points = [];
    const lang = 50;
    for ( let i = 0; i < lang; i +=0.2) {
        const y = start(i);
        points.push( new THREE.Vector2(y, i  ) );
    }

    /**
     * points包含了(y,x)坐标，通过这个定位光锥的坐标
     * **/
    const cone_texture = new THREE.TextureLoader().load("./lib/imgs/lightray_red.jpg");
    const cone_group = new THREE.Group();

    for(let i=25; i< points.length; i+=25) {
        const p = createCone(points[i]);
        cone_group.add(p.plane1);
        cone_group.add(p.plane2);
    }
    /** 光锥创建方法 **/

    function createCone(position) {
        var material = new THREE.MeshBasicMaterial({ // 基本材质
            map: cone_texture,
            transparent: true,
            depthTest: true,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending
        });
        var height = 1.5;
        var width = 0.5;
        var geometry = new THREE.PlaneGeometry(width, height);
        var matrix1 = new THREE.Matrix4();
        var plane1 = new THREE.Mesh(geometry, material);
        // matrix1.makeRotationY(Math.PI/180 * 90);
       // matrix1.setPosition(new THREE.Vector3(0,0, height/-2));
      // geometry.applyMatrix(matrix1);


        plane1.rotation.z = Math.PI / 180 * 90;
        plane1.position.y = height * 100;
        let plane2 = plane1.clone();
        plane2.rotation.x = Math.PI / 180 * 90;

        plane1.position.copy(new THREE.Vector3(position.x + height / 2, position.y, 0));
        plane2.position.copy(new THREE.Vector3(position.x + height / 2, position.y, 0));

        return {plane1: plane1, plane2: plane2};
    }

    /** THREE提供的根据曲线生成物体网格 **/
    const water_m = new THREE.LatheBufferGeometry(points, 20);

    const water_mesh = new THREE.Mesh(water_m, cubeMeterial);
    water_mesh.rotation.set(0,0,Math.PI/2);
    water_mesh.position.x = 15;

    console.log(water_mesh);
  scene.add(water_mesh);

    //cone_group.rotation.set(0,-Math.PI/180 * 90,0);
    var cone_group1 = cone_group.clone();
    var cone_group2 = cone_group.clone();
    cone_group1.rotation.y = Math.PI / 180 * 120;
    cone_group2.rotation.y = Math.PI / 180 * -120;
    water_mesh.add(cone_group);
    water_mesh.add(cone_group1);
    water_mesh.add(cone_group2);


    /** 慢速星空 **/
    /** star纹理 **/
    function makeStarTexture(){
        var canvas = document.createElement('canvas');
        canvas.width = 16;
        canvas.height = 16;
        var pen = canvas.getContext('2d');
        var gradient = pen.createRadialGradient(
            canvas.width/2,canvas.height/2,0,canvas.width/2,canvas.height/2,canvas.width/2
        );//创建放射状渐变
        gradient.addColorStop(0,'rgba(255,255,255,1)');
        gradient.addColorStop(0.2,'rgba(0,255,255,1)');
        gradient.addColorStop(0.4,'rgba(0,0,164,1)');
        gradient.addColorStop(1,'rgba(0,0,0,1)');
        pen.fillStyle = gradient;						//将笔触填充色设置为这个渐变放射状
        pen.fillRect(0,0,canvas.width,canvas.height);	//画矩形
        var texture = new THREE.Texture(canvas);		//生成贴图对象（参数是图片或canvas画布）
        texture.needsUpdate = true;						//将这个对象缓存到GPU
        return texture;
    }
    /** 创建星空基本粒子系统 **/
    var cloud, cloud2, lineMesh, lineMesh2;
    function initStarSky(){
        //粒子材质
        var material = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 3,
            transparent: true,
            blending: THREE.AdditiveBlending,
            map: makeStarTexture()
        });

        var geom = new THREE.Geometry();
        var range = 500;
        var rangex = 2000;
        for (var i = 0; i < 10000; i++) {
            var particle = new THREE.Vector3(Math.random() * rangex - rangex / 2, Math.random() * range - range / 2, Math.random() * range - range / 2);
            geom.vertices.push(particle);
            var color = new THREE.Color(0x00ffcc);
            // color.setHSL(color.getHSL().h, color.getHSL().s, Math.random() * color.getHSL().l);
            geom.colors.push(color);
        }

        // 创建粒子系统，相当于abc中的c
        cloud = new THREE.Points(geom, material);//参数是形状和材质
        cloud2 = new THREE.Points(geom, material); // 创建第2个

        cloud.sortParticles = true;					//粒子重新排序
        cloud2.sortParticles = true;
        cloud2.position.x = 2000;
      scene.add(cloud);
     scene.add(cloud2);

        /**
         * 线性立方体
         * **/
        var geometry = new THREE.BufferGeometry();
        var points = [];
        /** 定义顶点 **/
        for(let i=0; i<1000; i++) {
            const x = Math.random() * 3000 - 1500;
            const y = Math.random() * 500 - 250;
            const z = Math.random() * 500 - 250;
            const lang = Math.random() * 100 + 200;
            points.push(x,y,z,x+lang, y ,z);
        }

        geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( points, 3 ) ); // 设置顶点们

        var material = new THREE.LineBasicMaterial({
            color: 0x638DAF,
            linewidth: 1,
            linecap: 'square',
            linejoin: 'bevel',
        });
        lineMesh = new THREE.LineSegments(geometry, material);
        lineMesh2 = lineMesh.clone();
        lineMesh2.position.x = 3000;
      scene.add(lineMesh);
      scene.add(lineMesh2);
    }

   initStarSky();

    /** 高速时空隧道 **/
    const tunnel_points = [];
    for (var i = 0; i <= 4; i += 1) {
        if(i===0 || i===4){
            tunnel_points.push(new THREE.Vector3(1, 600 * i));
        }
        tunnel_points.push(new THREE.Vector3(100, 600 * i));
    }

    const tunnel_geometry = new THREE.LatheBufferGeometry(tunnel_points, 20);
    const tunnel_texture = new THREE.TextureLoader().load("./lib/imgs/001_electric.jpg");
    tunnel_texture.wrapT = tunnel_texture.wrapS = THREE.RepeatWrapping;
    tunnel_texture.repeat.set(6, 6);

    const tunnel_material = new THREE.MeshBasicMaterial({
        side: THREE.BackSide,
        transparent: true,
        alphaMap: tunnel_texture,
        color: 0x3333aa,
    });

    const tunnel = new THREE.Mesh(tunnel_geometry, tunnel_material);
    tunnel.rotation.z = Math.PI/180 * 90;
    tunnel.position.x = 1200;
    scene.add(tunnel);

    /* 生成天空盒 */
    var skybox;
    function initSkyBox(){
        var urls = ["lib/skybox/posx.png","lib/skybox/negx.png",
            "lib/skybox/posy.png","lib/skybox/negy.png",
            "lib/skybox/posz.png","lib/skybox/negz.png"];
        var loader = new THREE.CubeTextureLoader();

        var textureCube = loader.load(urls);	//这是采用同步的方式，也可以异步

        var shader = THREE.ShaderLib["cube"];
        shader.uniforms["tCube"].value = textureCube;
        var material = new THREE.ShaderMaterial({
            fragmentShader:shader.fragmentShader,
            vertexShader:shader.vertexShader,
            uniforms:shader.uniforms,
            depthWrite:false,
            side:THREE.BackSide
        });
        skybox = new THREE.Mesh(new THREE.BoxGeometry(2000,2000,2000),material);
     //  scene.add(skybox);
    }
   // initSkyBox();

    // 飞船附加物

    /** 线圈 **/
    var ship_g = new THREE.Geometry();
    for( let j = 0; j < Math.PI * 2.1; j += 2 * Math.PI / 180 ) {
        let v = new THREE.Vector3( Math.cos( j ), Math.sin( j ), 0 );
        ship_g.vertices.push( v );
    }
    var line = new MeshLine();
    line.setGeometry(ship_g);
    // 实现线圈材质
    var ship_line = new MeshLineMaterial({
        color: new THREE.Color(0x70c1b3),
        lineWidth: .05,
        transparent: true,
        opacity: 0,
        side: THREE.DoubleSide
    });

    // 虚线线圈材质
    var ship_dash = new MeshLineMaterial({
        color: new THREE.Color(0x70c1b3),
        lineWidth: .05,
        dashArray: 0.333,
        dashRatio: 0.666,
        opacity: 0,
        transparent: true,
        side: THREE.DoubleSide,
    });

    // 红色虚线材质
    var ship_red_dash = new MeshLineMaterial({
        color: new THREE.Color(0xFF4308),
        dashArray: 0.5,
        dashRatio: 0.5,
        transparent: true,
        lineWidth: .05,
    });

    // 红色实线材质
    var ship_red_line = new MeshLineMaterial({
        color: new THREE.Color(0xFF4308),
        transparent: true,
        opacity: 0,
        lineWidth: .1,
    });
    
    var line1_mesh = new THREE.Mesh(line.geometry, ship_line);
    line1_mesh.scale.set(0.01,0.01,0.01); // 3,3,3
    line1_mesh.rotation.y = Math.PI/180 * 90;
    line1_mesh.position.x = 10; // 20
    scene.add(line1_mesh);

    var line2_mesh = line1_mesh.clone();
    line2_mesh.scale.set(0.01,0.01,0.01); // 8,8,8
    line2_mesh.position.x = 10; // 17
    scene.add(line2_mesh);

    var line3_mesh = line1_mesh.clone();
    line3_mesh.scale.set(0.01,0.01,0.01); // 1.5,1.5,1.5
    line3_mesh.position.x = -23; // -33
    scene.add(line3_mesh);

    var q4_mesh = new THREE.Mesh(line.geometry, ship_red_dash);
    q4_mesh.scale.set(0.01,0.01,0.01); // 1.5, 1.5, 1.5
    q4_mesh.rotation.y = Math.PI/180 * 90;
    q4_mesh.position.x = 6; // 16
    scene.add(q4_mesh);

    var q5_mesh = q4_mesh.clone();
    q5_mesh.scale.set(0.01,0.01,0.01); // 1.3,1.3,1.3
    q5_mesh.position.x = -23.5; // -33.5
    scene.add(q5_mesh);

    var dash1_mesh = new THREE.Mesh(line.geometry, ship_dash);
    dash1_mesh.scale.set(4,4,4); // 3.3, 3.3, 3.3
    dash1_mesh.rotation.y = Math.PI/180 * 90;
    dash1_mesh.position.x = 20;
    scene.add(dash1_mesh);

    /** 3个红色三角 **/
    var ship_line4_g = new THREE.Geometry();
    ship_line4_g.vertices.push(new THREE.Vector3(0, 7, 0));
    ship_line4_g.vertices.push(new THREE.Vector3(0, 5, 0));

    var line4 = new MeshLine();
    line4.setGeometry(ship_line4_g, function(p){return 1-p;});

    var line4_mesh = new THREE.Mesh(line4.geometry, ship_red_line);
    line4_mesh.position.set(17, 0, 0);

    var line5_mesh = line4_mesh.clone();
    var line6_mesh = line4_mesh.clone();

    line5_mesh.rotation.x = Math.PI/180 * 120;
    line6_mesh.rotation.x = Math.PI/180 * 240;

    var line_group = new THREE.Group();
    line_group.add(line4_mesh);
    line_group.add(line5_mesh);
    line_group.add(line6_mesh);
    scene.add(line_group);

    /**
     * 添加铭牌
     * **/

    // 顶部标签
    var label1Div = document.createElement( 'div' );
    label1Div.className = 'title2d';
    label1Div.id = 'title2d';
    label1Div.innerHTML = '<div class="t">Waterdrop</div><div class="l1"></div><div class="l2"></div>';

    var label1 = new THREE.CSS2DObject( label1Div );
    label1.position.set( 15, 15, 0); // 将其坐标设置为原点偏上
    water_mesh.add( label1 );

    // 后部标签
    var label2Div = document.createElement('div');
    label2Div.className= "label2";
    label2Div.id = "label2";
    label2Div.innerHTML = '<p>这是2.0版本的"水滴"</p><p>配置了<i>曲率驱动引擎</i>及强互作用力外壳</p><p>由半人马星座α星系朝着太阳系行进</p><p>约<i>4个地球年</i>后抵达</p><p>哈勃望远镜已能捕获其图像</p>';
    var label2 = new THREE.CSS2DObject(label2Div);
    label2.position.set( 10, 50, 0);
    water_mesh.add(label2);

    /** 铭牌渲染器 **/
    const labelRenderer = new THREE.CSS2DRenderer();
    labelRenderer.setSize( window.innerWidth, window.innerHeight );
    labelRenderer.domElement.style.position = 'absolute';
    labelRenderer.domElement.style.top = 0;
    document.body.appendChild( labelRenderer.domElement );

    /** 后期处理 **/
    var composer = new THREE.EffectComposer( renderer );

    var renderPass = new THREE.RenderPass( scene, camera );
    composer.addPass( renderPass );

    var outlinePass = new THREE.OutlinePass( new THREE.Vector2( window.innerWidth, window.innerHeight ), scene, camera );
    composer.addPass( outlinePass );

    var effectFXAA = new THREE.ShaderPass( THREE.FXAAShader );

    effectFXAA.uniforms[ 'resolution' ].value.set( 1 / window.innerWidth, 1 / window.innerHeight );
    effectFXAA.renderToScreen = true;
    composer.addPass( effectFXAA );

    outlinePass.selectedObjects = [];

    /** 射线选中 **/
    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2(10000, 10000);

    function onMouseMove(e) {
        mouse.x = (e.clientX/window.innerWidth) * 2 -1;
        mouse.y = - (e.clientY/window.innerHeight) * 2 + 1;
    }
    window.addEventListener('mousemove', onMouseMove, false);


    /** =================================
     * 以下不变
     * ================================== **/
        // 渲染方法
    var count=0;
    var time = new THREE.Clock();

    console.log('TITLE2D:', title2d);
    function animate() {
        requestAnimationFrame(animate);
        stats.update();
        line_group.rotation.x += 0.01;
        dash1_mesh.rotation.x -= 0.01;
        cloud.position.x -= 10;
        cloud2.position.x -= 10;
        lineMesh.position.x -= 60;
        lineMesh2.position.x -= 60;
        q4_mesh.rotation.x -= 0.04;
        q5_mesh.rotation.x -= 0.04;
        tunnel_texture.offset.x += 0.01;
        tunnel_texture.offset.y -= 0.06;

        if(cloud.position.x <= -1500) {
            cloud.position.x = 2500;
        }
        if(cloud2.position.x <= -1500) {
            cloud2.position.x = 2500;
        }
        if(lineMesh.position.x <= -3000) {
            lineMesh.position.x = 3000;
        }
        if(lineMesh2.position.x <= -3000) {
            lineMesh2.position.x = 3000;
        }

        raycaster.setFromCamera(mouse, camera);
        var intersects = raycaster.intersectObjects([water_mesh]);

        if(intersects.length){ // 被选中
            title2d && !title2d.hasClass('show') && title2d.addClass('show');
            label2d && !label2d.hasClass('show') && label2d.addClass('show');
            // 前面中圈
            if(line1_mesh.position.x < 20) {
                line1_mesh.position.x += 1;
            }
            if(line1_mesh.scale.x < 3) {
                const scale = line1_mesh.scale.x + 0.1;
                line1_mesh.scale.set(scale, scale, scale);
            }
            // 前面大圈
            if(line2_mesh.position.x < 17) {
                line2_mesh.position.x += 1;
            }
            if(line2_mesh.scale.x < 8) {
                const scale = line2_mesh.scale.x + 0.4;
                line2_mesh.scale.set(scale, scale, scale);
            }
            // 后面小圈
            if(line3_mesh.position.x>-33) {
                line3_mesh.position.x -= 1;
            }
            if(line3_mesh.scale.x < 1.5) {
                const scale = line3_mesh.scale.x += 0.1;
                line3_mesh.scale.set(scale, scale, scale);
            }
            // 前面红色小圈
            if(q4_mesh.position.x < 16) {
                q4_mesh.position.x += 1;
            }
            if(q4_mesh.scale.x < 1.5) {
                const scale = q4_mesh.scale.x += 0.1;
                q4_mesh.scale.set(scale, scale, scale);
            }
            // 后面红色小圈
            if(q5_mesh.position.x > -33.5) {
                q5_mesh.position.x -= 1;
            }
            if(q5_mesh.scale.x < 1.5) {
                const scale = q5_mesh.scale.x += 0.1;
                q5_mesh.scale.set(scale, scale, scale);
            }
            // 前面虚线中圈
            if(dash1_mesh.material.uniforms.opacity.value < 1) {
                dash1_mesh.material.uniforms.opacity.value += 0.02;
            }
            if(dash1_mesh.scale.x > 3.3) {
                const scale = dash1_mesh.scale.x -= 0.1;
                dash1_mesh.scale.set(scale, scale, scale);
            }
            // 三个三角形的材质
            if(ship_red_line.uniforms.opacity.value < 1) {
                ship_red_line.uniforms.opacity.value += 0.01;
            }
            // 实现蓝色线圈材质
            if(ship_line.uniforms.opacity.value < 1) {
                ship_line.uniforms.opacity.value = 1;
            }
        } else { // 未被选中
            title2d && title2d.hasClass('show') && title2d.removeClass('show');
            label2d && label2d.hasClass('show') && label2d.removeClass("show");
            // 前面中圈
            if(line1_mesh.position.x > 10) {
                line1_mesh.position.x -= 1;
            }
            if(line1_mesh.scale.x > 0) {
                const scale = line1_mesh.scale.x - 0.1;
                line1_mesh.scale.set(scale, scale, scale);
            }
            // 前面大圈
            if(line2_mesh.position.x > 10) {
                line2_mesh.position.x -= 1;
            }
            if(line2_mesh.scale.x > 0) {
                const scale = line2_mesh.scale.x - 0.4;
                line2_mesh.scale.set(scale, scale, scale);
            }
            // 后面小圈
            if(line3_mesh.position.x<-23) {
                line3_mesh.position.x += 1;
            }
            if(line3_mesh.scale.x > 0) {
                const scale = line3_mesh.scale.x -= 0.1;
                line3_mesh.scale.set(scale, scale, scale);
            }
            // 前面红色小圈
            if(q4_mesh.position.x > 6) {
                q4_mesh.position.x -= 1;
            }
            if(q4_mesh.scale.x > 0) {
                const scale = q4_mesh.scale.x -= 0.1;
                q4_mesh.scale.set(scale, scale, scale);
            }
            // 后面红色小圈
            if(q5_mesh.position.x < -23.5) {
                q5_mesh.position.x += 1;
            }
            if(q5_mesh.scale.x > 0) {
                const scale = q5_mesh.scale.x -= 0.1;
                q5_mesh.scale.set(scale, scale, scale);
            }
            // 前面虚线中圈
            if(dash1_mesh.material.uniforms.opacity.value > 0) {
                dash1_mesh.material.uniforms.opacity.value = 0;
            }
            if(dash1_mesh.scale.x < 7) {
                dash1_mesh.scale.set(7, 7, 7);
            }
            // 三个三角形的材质
            if(ship_red_line.uniforms.opacity.value > 0) {
                ship_red_line.uniforms.opacity.value = 0;
            }
            // 实现蓝色线圈材质
            if(ship_line.uniforms.opacity.value > 0) {
                ship_line.uniforms.opacity.value -= 0.05;
            }
        }

        if ( count % 2 === 0 ) {
            cubeMeterial.envMap = cubeCamera1.renderTarget.texture;
            cubeCamera2.update( renderer, scene );
        } else {
            cubeMeterial.envMap = cubeCamera2.renderTarget.texture;
            cubeCamera1.update( renderer, scene );
        }
        count ++;

       // composer.render();
       labelRenderer.render( scene, camera );
        renderer.render(scene, camera);
    }
    animate();

    var title2d;
    var label2d;
    setTimeout(()=> {title2d = $("#title2d");label2d = $("#label2")}, 100);
</script>
</body>
</html>